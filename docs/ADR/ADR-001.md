
#### ADR-001 : Bus d’événements + Event Store + CQRS avec Redis Streams

Statut: Accepted  

Contexte
- Labo 7 requiert une architecture événementielle (Pub/Sub), un Event Store avec relecture, et CQRS.  
- Les services existants (catalogue, inventaire, commandes, e-commerce) sont déjà conteneurisés et exposés via Kong.  
- Besoin d’un broker simple à opérer localement, d’une persistance légère pour les événements, et d’une projection CQRS consultable.

Décision
- Utiliser Redis Streams comme bus Pub/Sub et comme Event Store minimal.  
- Standardiser les événements JSON (champs: `type`, `payload`, `emitted_at`, `checkout_id`/correlation).  
- Exposer un service Event Store (Flask) en lecture:  
  - `GET /api/event-store/streams/<stream>/events` (listing brut),  
  - `GET /api/event-store/replay/checkout/<checkout_id>` (reconstruction fonctionnelle d’un checkout),  
  - `GET /api/event-store/cqrs/orders-by-client/<client_id>` (lecture CQRS).  
- Construire des projections CQRS directement depuis le flux: un worker `cqrs-projection-worker` alimente un read-model Redis (clé par `client_id`).
- Assigner un consumer group DÉDIÉ par worker pour obtenir un comportement broadcast (sinon, un seul abonné par groupe reçoit le message).  
  - Ex.: `checkout-notification`, `checkout-audit`, `checkout-cqrs`, etc.

Alternatives considérées
- Kafka: robuste et scalable, mais plus lourd à opérer pour un labo; tooling supplémentaire (schema registry) non requis ici.  
- RabbitMQ: excellent pour queues, moins naturel pour le replay temporel de flux.  
- Base SQL comme Event Store (table `events`): simple, mais moins adaptée au fan-out et à la consommation concurrente par groupes.

Conséquences
- Positives:  
  - Découplage fort (plusieurs abonnés indépendants: notification, audit, CQRS).  
  - Relecture possible pour reconstruire l’état d’un checkout sans rejouer les effets de bord.  
  - Observabilité granulaire par topic et par type d’événement.  
- Négatives:  
  - Redis Streams offre de l’« at-least-once »: nécessite idempotence côté consommateurs.  
  - Gestion de rétention/trim non configurée en production (à documenter si besoin).  
  - Le replay applicatif ne doit jamais réémettre d’effets (Strictement lecture/calcul d’état).

Détails d’implémentation
- Flux principal: `ecommerce.checkout.events`.  
- Enveloppe d’événement:  
  - `type`: nom métier (`CheckoutInitiated`, `StockReserved`, ...).  
  - `payload`: données métier (dont `checkout_id`, `client_id`, `panier`, `reason`).  
  - `emitted_at`: timestamp epoch secondes.  
- Idempotence:  
  - Consommateurs tiennent compte de `message_id`/`checkout_id` et ne reperforment pas la même mutation (ex.: `stock_reservation_worker` et `stock_compensation_worker`).  
- CQRS:  
  - Le `cqrs-projection-worker` met à jour une vue `orders-by-client` dans Redis, interrogée par l’Event Store.  
- Observabilité:  
  - Prometheus métriques: compteurs publication/consommation, histogramme de latence par type d’événement, compteurs de succès/échec de saga.  
  - Dashboard Grafana dédié (event-bus + saga).

Sécurité et exploitation
- Accès aux APIs métier via Kong avec `X-API-Key`.  
- Workers isolés par consumer group pour garantir la diffusion à tous les abonnés.  
- Retentatives gérées côté HTTP (timeouts) et idempotence côté domaine.

