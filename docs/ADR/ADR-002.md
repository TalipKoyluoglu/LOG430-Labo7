#### ADR-002 : Saga Chorégraphiée pour le Checkout e-commerce (sans orchestrateur)

Statut: Accepted  

Contexte
- La Partie 2 du Labo 7 exige une saga chorégraphiée, où la coordination se fait par événements, sans service central.  
- Les services impliqués: e-commerce (publisher initial), inventaire (réservation/compensation), commandes (création), plus des abonnés transverses (notification, audit, CQRS).  
- Redis Streams est déjà en place comme bus/pub-sub et Event Store.

Décision
- Remplacer la coordination centrale (orchestrateur) par des workers découplés qui réagissent aux événements:  
  - `ecommerce-service`: publie `CheckoutInitiated` (détails du panier).  
  - `stock_reservation_worker`: consomme `CheckoutInitiated`, réserve le stock via l’API inventaire; publie `StockReserved` ou `StockReservationFailed`.  
  - `order_creation_worker`: consomme `StockReserved`, crée la commande via l’API commandes; publie `OrderCreated` et `CheckoutSucceeded`, ou `OrderCreationFailed`.  
  - `stock_compensation_worker`: consomme `OrderCreationFailed`/`StockReservationFailed`, restaure le stock; publie `StockReleased` et `CheckoutFailed`.  
  - Abonnés transverses: `notification_worker`, `audit_worker`, `cqrs_projection_worker`.  
- Garantir la diffusion à tous les abonnés pertinents en attribuant un consumer group distinct par worker.

Alternatives considérées
- Saga orchestrée (déjà réalisée en Labo 6): bonne visibilité mais point central de défaillance et couplage temporel.  
- 2PC/transactions distribuées: non adapté au découplage microservices et aux contraintes d’autonomie.  
- Coreographie sur un autre broker (Kafka): plus lourd pour le contexte du labo.

Conséquences
- Positives:  
  - Couplage faible entre étapes; tolérance aux pannes accrue; extensibilité (ajout d’abonnés sans changer le producteur).  
  - Traçabilité via Event Store; relecture pour diagnostic; CQRS aligné sur le flux.  
  - Observabilité: métriques par worker et par type d’événement; succès/échecs de saga.  
- Négatives:  
  - Discipline d’idempotence nécessaire (au moins une fois).  
  - Gestion explicite des consumer groups pour éviter l’effet “queue” et perdre le broadcast.  
  - Debugging distribué: nécessite corrélation par `checkout_id` et bons dashboards.

Détails d’implémentation
- Topics: `ecommerce.checkout.events`.  
- Contrats d’événements: `CheckoutInitiated`, `StockReserved`, `StockReservationFailed`, `OrderCreated`, `OrderCreationFailed`, `StockReleased`, `CheckoutSucceeded`, `CheckoutFailed`.  
- Compensation: déclenchée sur `OrderCreationFailed` ou `StockReservationFailed`.  
- Idempotence: handlers évitent les double-traitements (e.g., vérifs de statuts, clés Redis pour marquer les étapes).  
- Observabilité: compteurs `saga_choreo_success_total` et `saga_choreo_failed_total`, histogramme de latence par type.

Critères d’acceptation
- Cas succès: replay montre la séquence complète jusqu’à `CheckoutSucceeded` et projection CQRS mise à jour.  
- Cas échec partiel: replay montre la compensation (`StockReleased`) et `CheckoutFailed`.  
- Les abonnés de notification et d’audit reçoivent bien les mêmes événements grâce à leurs consumer groups dédiés.  
- Dashboards Grafana reflètent l’activité (taux, latence, succès/échecs).